module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.30.5). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateGemRewardType {
  count: Int!
}

type AggregateGemTransaction {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateUserWallet {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

type GemRewardType {
  id: Int!
  amount: Int
  contents: String
  createTime: DateTime
  updateTime: DateTime
}

type GemRewardTypeConnection {
  pageInfo: PageInfo!
  edges: [GemRewardTypeEdge]!
  aggregate: AggregateGemRewardType!
}

input GemRewardTypeCreateInput {
  amount: Int
  contents: String
  createTime: DateTime
  updateTime: DateTime
}

type GemRewardTypeEdge {
  node: GemRewardType!
  cursor: String!
}

enum GemRewardTypeOrderByInput {
  id_ASC
  id_DESC
  amount_ASC
  amount_DESC
  contents_ASC
  contents_DESC
  createTime_ASC
  createTime_DESC
  updateTime_ASC
  updateTime_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type GemRewardTypePreviousValues {
  id: Int!
  amount: Int
  contents: String
  createTime: DateTime
  updateTime: DateTime
}

type GemRewardTypeSubscriptionPayload {
  mutation: MutationType!
  node: GemRewardType
  updatedFields: [String!]
  previousValues: GemRewardTypePreviousValues
}

input GemRewardTypeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GemRewardTypeWhereInput
  AND: [GemRewardTypeSubscriptionWhereInput!]
  OR: [GemRewardTypeSubscriptionWhereInput!]
  NOT: [GemRewardTypeSubscriptionWhereInput!]
}

input GemRewardTypeUpdateInput {
  amount: Int
  contents: String
  createTime: DateTime
  updateTime: DateTime
}

input GemRewardTypeUpdateManyMutationInput {
  amount: Int
  contents: String
  createTime: DateTime
  updateTime: DateTime
}

input GemRewardTypeWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  amount: Int
  amount_not: Int
  amount_in: [Int!]
  amount_not_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_gt: Int
  amount_gte: Int
  contents: String
  contents_not: String
  contents_in: [String!]
  contents_not_in: [String!]
  contents_lt: String
  contents_lte: String
  contents_gt: String
  contents_gte: String
  contents_contains: String
  contents_not_contains: String
  contents_starts_with: String
  contents_not_starts_with: String
  contents_ends_with: String
  contents_not_ends_with: String
  createTime: DateTime
  createTime_not: DateTime
  createTime_in: [DateTime!]
  createTime_not_in: [DateTime!]
  createTime_lt: DateTime
  createTime_lte: DateTime
  createTime_gt: DateTime
  createTime_gte: DateTime
  updateTime: DateTime
  updateTime_not: DateTime
  updateTime_in: [DateTime!]
  updateTime_not_in: [DateTime!]
  updateTime_lt: DateTime
  updateTime_lte: DateTime
  updateTime_gt: DateTime
  updateTime_gte: DateTime
  AND: [GemRewardTypeWhereInput!]
  OR: [GemRewardTypeWhereInput!]
  NOT: [GemRewardTypeWhereInput!]
}

input GemRewardTypeWhereUniqueInput {
  id: Int
}

type GemTransaction {
  id: Int!
  amount: Int
  blockNumber: String
  createTime: DateTime
  receiverAddress: String
  receiverUserRowId: Int
  rewardType: String
  senderAddress: String
  senderUserRowId: Int
  status: Boolean
  txhash: String
}

type GemTransactionConnection {
  pageInfo: PageInfo!
  edges: [GemTransactionEdge]!
  aggregate: AggregateGemTransaction!
}

input GemTransactionCreateInput {
  amount: Int
  blockNumber: String
  createTime: DateTime
  receiverAddress: String
  receiverUserRowId: Int
  rewardType: String
  senderAddress: String
  senderUserRowId: Int
  status: Boolean
  txhash: String
}

type GemTransactionEdge {
  node: GemTransaction!
  cursor: String!
}

enum GemTransactionOrderByInput {
  id_ASC
  id_DESC
  amount_ASC
  amount_DESC
  blockNumber_ASC
  blockNumber_DESC
  createTime_ASC
  createTime_DESC
  receiverAddress_ASC
  receiverAddress_DESC
  receiverUserRowId_ASC
  receiverUserRowId_DESC
  rewardType_ASC
  rewardType_DESC
  senderAddress_ASC
  senderAddress_DESC
  senderUserRowId_ASC
  senderUserRowId_DESC
  status_ASC
  status_DESC
  txhash_ASC
  txhash_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type GemTransactionPreviousValues {
  id: Int!
  amount: Int
  blockNumber: String
  createTime: DateTime
  receiverAddress: String
  receiverUserRowId: Int
  rewardType: String
  senderAddress: String
  senderUserRowId: Int
  status: Boolean
  txhash: String
}

type GemTransactionSubscriptionPayload {
  mutation: MutationType!
  node: GemTransaction
  updatedFields: [String!]
  previousValues: GemTransactionPreviousValues
}

input GemTransactionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GemTransactionWhereInput
  AND: [GemTransactionSubscriptionWhereInput!]
  OR: [GemTransactionSubscriptionWhereInput!]
  NOT: [GemTransactionSubscriptionWhereInput!]
}

input GemTransactionUpdateInput {
  amount: Int
  blockNumber: String
  createTime: DateTime
  receiverAddress: String
  receiverUserRowId: Int
  rewardType: String
  senderAddress: String
  senderUserRowId: Int
  status: Boolean
  txhash: String
}

input GemTransactionUpdateManyMutationInput {
  amount: Int
  blockNumber: String
  createTime: DateTime
  receiverAddress: String
  receiverUserRowId: Int
  rewardType: String
  senderAddress: String
  senderUserRowId: Int
  status: Boolean
  txhash: String
}

input GemTransactionWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  amount: Int
  amount_not: Int
  amount_in: [Int!]
  amount_not_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_gt: Int
  amount_gte: Int
  blockNumber: String
  blockNumber_not: String
  blockNumber_in: [String!]
  blockNumber_not_in: [String!]
  blockNumber_lt: String
  blockNumber_lte: String
  blockNumber_gt: String
  blockNumber_gte: String
  blockNumber_contains: String
  blockNumber_not_contains: String
  blockNumber_starts_with: String
  blockNumber_not_starts_with: String
  blockNumber_ends_with: String
  blockNumber_not_ends_with: String
  createTime: DateTime
  createTime_not: DateTime
  createTime_in: [DateTime!]
  createTime_not_in: [DateTime!]
  createTime_lt: DateTime
  createTime_lte: DateTime
  createTime_gt: DateTime
  createTime_gte: DateTime
  receiverAddress: String
  receiverAddress_not: String
  receiverAddress_in: [String!]
  receiverAddress_not_in: [String!]
  receiverAddress_lt: String
  receiverAddress_lte: String
  receiverAddress_gt: String
  receiverAddress_gte: String
  receiverAddress_contains: String
  receiverAddress_not_contains: String
  receiverAddress_starts_with: String
  receiverAddress_not_starts_with: String
  receiverAddress_ends_with: String
  receiverAddress_not_ends_with: String
  receiverUserRowId: Int
  receiverUserRowId_not: Int
  receiverUserRowId_in: [Int!]
  receiverUserRowId_not_in: [Int!]
  receiverUserRowId_lt: Int
  receiverUserRowId_lte: Int
  receiverUserRowId_gt: Int
  receiverUserRowId_gte: Int
  rewardType: String
  rewardType_not: String
  rewardType_in: [String!]
  rewardType_not_in: [String!]
  rewardType_lt: String
  rewardType_lte: String
  rewardType_gt: String
  rewardType_gte: String
  rewardType_contains: String
  rewardType_not_contains: String
  rewardType_starts_with: String
  rewardType_not_starts_with: String
  rewardType_ends_with: String
  rewardType_not_ends_with: String
  senderAddress: String
  senderAddress_not: String
  senderAddress_in: [String!]
  senderAddress_not_in: [String!]
  senderAddress_lt: String
  senderAddress_lte: String
  senderAddress_gt: String
  senderAddress_gte: String
  senderAddress_contains: String
  senderAddress_not_contains: String
  senderAddress_starts_with: String
  senderAddress_not_starts_with: String
  senderAddress_ends_with: String
  senderAddress_not_ends_with: String
  senderUserRowId: Int
  senderUserRowId_not: Int
  senderUserRowId_in: [Int!]
  senderUserRowId_not_in: [Int!]
  senderUserRowId_lt: Int
  senderUserRowId_lte: Int
  senderUserRowId_gt: Int
  senderUserRowId_gte: Int
  status: Boolean
  status_not: Boolean
  txhash: String
  txhash_not: String
  txhash_in: [String!]
  txhash_not_in: [String!]
  txhash_lt: String
  txhash_lte: String
  txhash_gt: String
  txhash_gte: String
  txhash_contains: String
  txhash_not_contains: String
  txhash_starts_with: String
  txhash_not_starts_with: String
  txhash_ends_with: String
  txhash_not_ends_with: String
  AND: [GemTransactionWhereInput!]
  OR: [GemTransactionWhereInput!]
  NOT: [GemTransactionWhereInput!]
}

input GemTransactionWhereUniqueInput {
  id: Int
}

scalar Long

type Mutation {
  createGemRewardType(data: GemRewardTypeCreateInput!): GemRewardType!
  updateGemRewardType(data: GemRewardTypeUpdateInput!, where: GemRewardTypeWhereUniqueInput!): GemRewardType
  updateManyGemRewardTypes(data: GemRewardTypeUpdateManyMutationInput!, where: GemRewardTypeWhereInput): BatchPayload!
  upsertGemRewardType(where: GemRewardTypeWhereUniqueInput!, create: GemRewardTypeCreateInput!, update: GemRewardTypeUpdateInput!): GemRewardType!
  deleteGemRewardType(where: GemRewardTypeWhereUniqueInput!): GemRewardType
  deleteManyGemRewardTypes(where: GemRewardTypeWhereInput): BatchPayload!
  createGemTransaction(data: GemTransactionCreateInput!): GemTransaction!
  updateGemTransaction(data: GemTransactionUpdateInput!, where: GemTransactionWhereUniqueInput!): GemTransaction
  updateManyGemTransactions(data: GemTransactionUpdateManyMutationInput!, where: GemTransactionWhereInput): BatchPayload!
  upsertGemTransaction(where: GemTransactionWhereUniqueInput!, create: GemTransactionCreateInput!, update: GemTransactionUpdateInput!): GemTransaction!
  deleteGemTransaction(where: GemTransactionWhereUniqueInput!): GemTransaction
  deleteManyGemTransactions(where: GemTransactionWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createUserWallet(data: UserWalletCreateInput!): UserWallet!
  updateUserWallet(data: UserWalletUpdateInput!, where: UserWalletWhereUniqueInput!): UserWallet
  updateManyUserWallets(data: UserWalletUpdateManyMutationInput!, where: UserWalletWhereInput): BatchPayload!
  upsertUserWallet(where: UserWalletWhereUniqueInput!, create: UserWalletCreateInput!, update: UserWalletUpdateInput!): UserWallet!
  deleteUserWallet(where: UserWalletWhereUniqueInput!): UserWallet
  deleteManyUserWallets(where: UserWalletWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  gemRewardType(where: GemRewardTypeWhereUniqueInput!): GemRewardType
  gemRewardTypes(where: GemRewardTypeWhereInput, orderBy: GemRewardTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GemRewardType]!
  gemRewardTypesConnection(where: GemRewardTypeWhereInput, orderBy: GemRewardTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GemRewardTypeConnection!
  gemTransaction(where: GemTransactionWhereUniqueInput!): GemTransaction
  gemTransactions(where: GemTransactionWhereInput, orderBy: GemTransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GemTransaction]!
  gemTransactionsConnection(where: GemTransactionWhereInput, orderBy: GemTransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GemTransactionConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  userWallet(where: UserWalletWhereUniqueInput!): UserWallet
  userWallets(where: UserWalletWhereInput, orderBy: UserWalletOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserWallet]!
  userWalletsConnection(where: UserWalletWhereInput, orderBy: UserWalletOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserWalletConnection!
  node(id: ID!): Node
}

type Subscription {
  gemRewardType(where: GemRewardTypeSubscriptionWhereInput): GemRewardTypeSubscriptionPayload
  gemTransaction(where: GemTransactionSubscriptionWhereInput): GemTransactionSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  userWallet(where: UserWalletSubscriptionWhereInput): UserWalletSubscriptionPayload
}

type User {
  id: Int!
  code: String
  createTime: DateTime
  email: String
  updateTime: DateTime
  userId: Int
  walletId: UserWallet
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  code: String
  createTime: DateTime
  email: String
  updateTime: DateTime
  userId: Int
  walletId: UserWalletCreateOneWithoutUserInput
}

input UserCreateManyWithoutWalletIdInput {
  create: [UserCreateWithoutWalletIdInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateWithoutWalletIdInput {
  code: String
  createTime: DateTime
  email: String
  updateTime: DateTime
  userId: Int
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  code_ASC
  code_DESC
  createTime_ASC
  createTime_DESC
  email_ASC
  email_DESC
  updateTime_ASC
  updateTime_DESC
  userId_ASC
  userId_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: Int!
  code: String
  createTime: DateTime
  email: String
  updateTime: DateTime
  userId: Int
}

input UserScalarWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  createTime: DateTime
  createTime_not: DateTime
  createTime_in: [DateTime!]
  createTime_not_in: [DateTime!]
  createTime_lt: DateTime
  createTime_lte: DateTime
  createTime_gt: DateTime
  createTime_gte: DateTime
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  updateTime: DateTime
  updateTime_not: DateTime
  updateTime_in: [DateTime!]
  updateTime_not_in: [DateTime!]
  updateTime_lt: DateTime
  updateTime_lte: DateTime
  updateTime_gt: DateTime
  updateTime_gte: DateTime
  userId: Int
  userId_not: Int
  userId_in: [Int!]
  userId_not_in: [Int!]
  userId_lt: Int
  userId_lte: Int
  userId_gt: Int
  userId_gte: Int
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  code: String
  createTime: DateTime
  email: String
  updateTime: DateTime
  userId: Int
  walletId: UserWalletUpdateOneWithoutUserInput
}

input UserUpdateManyDataInput {
  code: String
  createTime: DateTime
  email: String
  updateTime: DateTime
  userId: Int
}

input UserUpdateManyMutationInput {
  code: String
  createTime: DateTime
  email: String
  updateTime: DateTime
  userId: Int
}

input UserUpdateManyWithoutWalletIdInput {
  create: [UserCreateWithoutWalletIdInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutWalletIdInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutWalletIdInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyDataInput!
}

input UserUpdateWithoutWalletIdDataInput {
  code: String
  createTime: DateTime
  email: String
  updateTime: DateTime
  userId: Int
}

input UserUpdateWithWhereUniqueWithoutWalletIdInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutWalletIdDataInput!
}

input UserUpsertWithWhereUniqueWithoutWalletIdInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutWalletIdDataInput!
  create: UserCreateWithoutWalletIdInput!
}

type UserWallet {
  id: Int!
  address: String
  createTime: DateTime
  status: Boolean
  updateTime: DateTime
  user(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  userRowId: Int
}

type UserWalletConnection {
  pageInfo: PageInfo!
  edges: [UserWalletEdge]!
  aggregate: AggregateUserWallet!
}

input UserWalletCreateInput {
  address: String
  createTime: DateTime
  status: Boolean
  updateTime: DateTime
  user: UserCreateManyWithoutWalletIdInput
  userRowId: Int
}

input UserWalletCreateOneWithoutUserInput {
  create: UserWalletCreateWithoutUserInput
  connect: UserWalletWhereUniqueInput
}

input UserWalletCreateWithoutUserInput {
  address: String
  createTime: DateTime
  status: Boolean
  updateTime: DateTime
  userRowId: Int
}

type UserWalletEdge {
  node: UserWallet!
  cursor: String!
}

enum UserWalletOrderByInput {
  id_ASC
  id_DESC
  address_ASC
  address_DESC
  createTime_ASC
  createTime_DESC
  status_ASC
  status_DESC
  updateTime_ASC
  updateTime_DESC
  userRowId_ASC
  userRowId_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserWalletPreviousValues {
  id: Int!
  address: String
  createTime: DateTime
  status: Boolean
  updateTime: DateTime
  userRowId: Int
}

type UserWalletSubscriptionPayload {
  mutation: MutationType!
  node: UserWallet
  updatedFields: [String!]
  previousValues: UserWalletPreviousValues
}

input UserWalletSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWalletWhereInput
  AND: [UserWalletSubscriptionWhereInput!]
  OR: [UserWalletSubscriptionWhereInput!]
  NOT: [UserWalletSubscriptionWhereInput!]
}

input UserWalletUpdateInput {
  address: String
  createTime: DateTime
  status: Boolean
  updateTime: DateTime
  user: UserUpdateManyWithoutWalletIdInput
  userRowId: Int
}

input UserWalletUpdateManyMutationInput {
  address: String
  createTime: DateTime
  status: Boolean
  updateTime: DateTime
  userRowId: Int
}

input UserWalletUpdateOneWithoutUserInput {
  create: UserWalletCreateWithoutUserInput
  update: UserWalletUpdateWithoutUserDataInput
  upsert: UserWalletUpsertWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWalletWhereUniqueInput
}

input UserWalletUpdateWithoutUserDataInput {
  address: String
  createTime: DateTime
  status: Boolean
  updateTime: DateTime
  userRowId: Int
}

input UserWalletUpsertWithoutUserInput {
  update: UserWalletUpdateWithoutUserDataInput!
  create: UserWalletCreateWithoutUserInput!
}

input UserWalletWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  createTime: DateTime
  createTime_not: DateTime
  createTime_in: [DateTime!]
  createTime_not_in: [DateTime!]
  createTime_lt: DateTime
  createTime_lte: DateTime
  createTime_gt: DateTime
  createTime_gte: DateTime
  status: Boolean
  status_not: Boolean
  updateTime: DateTime
  updateTime_not: DateTime
  updateTime_in: [DateTime!]
  updateTime_not_in: [DateTime!]
  updateTime_lt: DateTime
  updateTime_lte: DateTime
  updateTime_gt: DateTime
  updateTime_gte: DateTime
  user_every: UserWhereInput
  user_some: UserWhereInput
  user_none: UserWhereInput
  userRowId: Int
  userRowId_not: Int
  userRowId_in: [Int!]
  userRowId_not_in: [Int!]
  userRowId_lt: Int
  userRowId_lte: Int
  userRowId_gt: Int
  userRowId_gte: Int
  AND: [UserWalletWhereInput!]
  OR: [UserWalletWhereInput!]
  NOT: [UserWalletWhereInput!]
}

input UserWalletWhereUniqueInput {
  id: Int
}

input UserWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  createTime: DateTime
  createTime_not: DateTime
  createTime_in: [DateTime!]
  createTime_not_in: [DateTime!]
  createTime_lt: DateTime
  createTime_lte: DateTime
  createTime_gt: DateTime
  createTime_gte: DateTime
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  updateTime: DateTime
  updateTime_not: DateTime
  updateTime_in: [DateTime!]
  updateTime_not_in: [DateTime!]
  updateTime_lt: DateTime
  updateTime_lte: DateTime
  updateTime_gt: DateTime
  updateTime_gte: DateTime
  userId: Int
  userId_not: Int
  userId_in: [Int!]
  userId_not_in: [Int!]
  userId_lt: Int
  userId_lte: Int
  userId_gt: Int
  userId_gte: Int
  walletId: UserWalletWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: Int
}
`
      }
    